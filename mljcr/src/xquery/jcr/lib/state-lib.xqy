
xquery version "1.0-ml";

module namespace jcrstatelib="http://marklogic.com/jcr/state";

declare default element namespace "http://marklogic.com/jcr";

declare variable $STATE_DOC_NAME := "state.xml";

(: =============================================================== :)
(:
   Code in this section applies the change list generated by JackRabbit.
   It deletes node/properties, adds new ones and makes changes to
   existing ones.
   This does a recursive descent over the existing workspace state
   document and produces another one, which replaces the old one.
 :)

(: Find a node's name by looking it up by id in the change list.
   When added, it should appear as a child entry for some other
   node in the change list. :)
declare private function find-node-name ($deltas as element(change-list),
	$id as xs:string)
	as xs:string
{
	fn:string ($deltas//node/nodes/node[@uuid = $id]/@name)
};

(: Delete a property.  Delete the blob file for Binary properties,
   otherwise do nothing.
 :)
declare private function delete-property ($prop as element(property), $uri-root as xs:string)
	as empty-sequence()
{
	(: TODO: delete blob if type = Binary  ---  Finish this :)
	if ($prop/@type = "Binary")
	then xdmp:document-delete (fn:concat ($uri-root, fn:string ($prop/values/value)))
	else ()
};

(: Return a new property, which is the input property element unless
   it's of type binary.  For binary properties, a document may be created.
 :)
declare private function new-property ($prop as element(property))
	as element(property)
{
	(: TODO: handle binary properties, move/re-insert document :)
	$prop
};

(: Update this property, if it's on the list of modified properties.
   If modified, a new property is created, which may cause a binary
   document to be replaced.  If not modified, return the orginal element.
 :)
declare private function update-property ($prop as element(property),
	$deltas as element(change-list))
	as element(property)*
{
	if (fn:exists ($deltas/modified-states/property[@parrentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then new-property ($deltas/modified-states/property[@parentUUID = $prop/@parentUUID][@name = $prop/@name])
	else $prop
};

(: If the property is on the deletion list, return nothing.  Otherwise,
   return the original element.  The function delete-property() is called
   to (possibly) delete the document corresponding to a binary property.
 :)
declare private function prune-property ($prop as element(property),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(property)*
{
	if (fn:exists ($deltas/deleted-states/property[@parrentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then delete-property ($prop, $uri-root)
	else $prop
};

(: Given a <referenceds> node and the id of its parent node, if a new
   instance is in the change list, return that.  Otherwise return the
   original <references> element.
 :)
declare private function prune-references ($node-id as attribute(uuid),
	$refs as element(reference)*, $deltas as element(change-list))
	as element(reference)*
{
	if (fn:exists ($deltas/modified-refs/references[@targetId = $node-id]))
	then $deltas/modified-refs/references[@targetId = $node-id]/reference
	else $refs
};

(: If the candidate node does not exist in the sequence of existing nodes,
   construct and return a node, tagged with an "extref" attribute, to be
   used as a placeholder.  This case happens for nodes whose parent
   node lives in another workspace, which is allowed.
 :)
declare private function external-node ($existing-nodes as element(node)*,
	$candidate as element(node), $parent-id as xs:string)
{
	if (fn:exists ($existing-nodes[@uuid = $candidate/@uuid]))
	then ()
	else
	<node extref="true">{
		$candidate/@*,
		attribute { "parentUUID" } { $parent-id }
	}</node>
};

(: Returns nodes that are new, but which don't have a parent in this workspace
   TODO: Can this be unified with external-node(), above
 :)
declare private function parentless-new-nodes ($state as element(workspace),
	$deltas as element(change-list))
	as element(node)*
{
	for $new-node in $deltas/added-states/node
	let $parent-id := $new-node/@parentUUID
	where fn:empty (($deltas/added-states/node[@uuid = $parent-id],
			$state//node[@uuid = $parent-id]))
	return $new-node
};

(: Apply updates for this node.  An update could mean creating a new node,
   in which can the input node is the one in the change list.  The first
   step is to recurse down and apply updates to child nodes.  Once all
   children have been updated, a new node level is created and returned,
   which may entail replacing the current node with one from the change list.
   New nodes in the change list do not have name attributes, so the name
   is looked up (in other nodes in the changelist) if necessary.
   Note function mapping.
 :)
declare private function update-node ($node as element(node),
	$deltas as element(change-list))
	as element(node)?
{
	(: note function mapping :)
	let $node-id := $node/@uuid
	let $child-nodes := (update-node ($node/node, $deltas),
		update-node ($deltas/added-states/node[@parentUUID = $node-id], $deltas))
	let $added-external-nodes := external-node ($child-nodes,
		$deltas/(added-states|modified-states)/node[@uuid = $node-id]/nodes/node,
		fn:string ($node-id))
	let $child-properties := (update-property ($node/property, $deltas),
		new-property ($deltas/added-states/property[@parentUUID = $node-id]))
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	<node>{
		let $replace-node := $deltas/modified-states/node[@uuid = $node-id]
		let $name-attr := if ($node/@name)
			then $node/@name
			else attribute { "name" } { find-node-name ($deltas, $node-id) }
		let $node := if ($replace-node) then $replace-node else $node
		return
		(
			if ($node/@name) then () else $name-attr,
			$node/@*,
			$node/mixinTypes,
			$child-properties,
			$child-nodes,
			$added-external-nodes,
			$child-refs
		)
	}</node>
};

(: Attempt to prune this node.  Any child nodes and/or properties are
   first pruned in case they have been deleted.  Then the change list
   is checked to see if this node has been deleted.  If so, return the
   empty sequence.  If not deleted, return a copy of this node with the
   surviving child nodes.
   Note use of function mapping to automatically iterate child nodes.
 :)
declare private function prune-node ($node as element(node),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(node)?
{
	let $node-id := $node/@uuid
	let $child-nodes := prune-node ($node/node, $deltas, $uri-root)
	let $child-properties := prune-property ($node/property, $deltas, $uri-root)
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	if (fn:exists ($deltas/deleted-states/node[@uuid = $node-id]))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,
		$child-properties,
		$child-nodes,
		$child-refs
	}</node>
};

(: Apply updates to the workspace tree (adds and modifies).  This
   function assumes that deleted nodes/properies have already been
   pruned away.
 :)
declare private function apply-updates ($state as element(workspace),
	$deltas as element(change-list))
	as element(workspace)
{
	<workspace>{
		$state/@*,
		update-node ($state/node, $deltas),
		update-node (parentless-new-nodes ($state, $deltas), $deltas)
	}</workspace>
};


(: Recurse down the workspace state tree and prune out deleted nodes.
   Pruning nodes implies pruning contained properties, which may cause
   document deletions.
 :)
declare (: private :) function prune-deleted ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	<workspace>{
		$state/@*,
		prune-node ($state/node, $deltas, $uri-root)   (: function mapping here :)
	}</workspace>
};

(: Returns a new workspace node with deltas applied :)
declare function apply-state-updates ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	apply-updates (prune-deleted ($state, $deltas, $uri-root), $deltas)
};

(: =============================================================== :)

declare function check-node-exists ($state as element(workspace), $id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[@uuid = $id][fn:not(@extref)])
};

declare function query-node-state ($state as element(workspace), $id as xs:string)
	as element(node)?
{
	let $node as element(node)? := $state//node[@uuid = $id][fn:not(@extref)]

	return
	if (fn:empty ($node))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,

		<nodes>{
			for $n in $node/node
			return
			<node>{
				$n/@name, $n/@uuid
			}</node>
		}</nodes>,

		<properties>{
			for $prop in $node/property
			return
			<property>{$prop/@name}</property>
		}</properties>
	}</node>
};

(: =============================================================== :)

declare function check-property-exists ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name])
};

declare function query-property-state ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as element(property)?
{
	$state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name]
};

(: =============================================================== :)

declare function check-reference-exists ($state as element(workspace),
	$id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/reference)
};

declare function query-references-state ($state as element(workspace),
	$id as xs:string)
	as element(references)
{
	let $node := $state//node[fn:string(@uuid) = $id]
	return
	<references>{
		attribute { "targetId" } { $id },
		for $ref in $node/reference
		let $nodeId := fn:string ($ref/@parentUUID)
		let $propName := $ref/@name
		return
		<reference>{
			attribute { "propertyId" } { fn:concat ($nodeId, "/", $propName) }
		}</reference>
	}</references>
};

(: =============================================================== :)
