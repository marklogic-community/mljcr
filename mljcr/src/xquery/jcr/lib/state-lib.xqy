
xquery version "1.0-ml";

module namespace jcrstatelib="http://marklogic.com/jcr/state";

import module namespace jcrfslib="http://marklogic.com/jcr/fs" at "fs-lib.xqy";

declare default element namespace "http://marklogic.com/jcr";

(: keep this is sync with Java :)
declare variable $MAGIC_EMPTY_BLOB_ID := "@=-empty-=@";

declare variable $save-debug-history := fn:false();
declare variable $save-update-profile-data := fn:false();

(: =============================================================== :)
(: Debug functions to save update history :)

declare private function get-counter ($uri as xs:string) as xs:string
{
	let $prev-number as xs:integer? := xs:integer (fn:doc ($uri)/counter)
	let $number := if (fn:exists ($prev-number)) then ($prev-number + 1) else 1
	let $dummy := xdmp:document-insert ($uri, <counter>{$number}</counter>)
	return
	if ($number < 10)
	then fn:concat ("00", $number)
	else if ($number < 100)
	then fn:concat ("0", $number)
	else fn:string ($number)
};

declare private function save-debug-history ($uri-root as xs:string,
	$old-state as element(workspace), $pruned as element(workspace),
	$new-state as element(workspace), $deltas as element(change-list))
{
	let $base-uri := fn:concat ($uri-root, "/history/")
	let $counter-uri := fn:concat ($base-uri, "history-counter.xml")
	let $number := get-counter ($counter-uri)
	let $history-uri := fn:concat ($base-uri, "state-history-", $number, ".xml")
	return xdmp:document-insert ($history-uri,
		<history uri="{$history-uri}">
			<before>{$old-state}</before>
			<pruned>{$pruned}</pruned>
			<deltas>{$deltas}</deltas>
			<after>{$new-state}</after>
		</history>
	)
};

declare private function save-profile-data ($uri-root as xs:string,
	$profile as element(prof:report))
{
	let $base-uri := fn:concat ($uri-root, "/profile/")
	let $counter-uri := fn:concat ($base-uri, "history-counter.xml")
	let $number := get-counter ($counter-uri)
	let $history-uri := fn:concat ($base-uri, "profile-history-", $number, ".xml")
	return xdmp:document-insert ($history-uri, $profile)
};

(: =============================================================== :)


declare private function is-empty-blob ($prop as element(property))
	as xs:boolean
{
	if (fn:string ($prop/values/value) eq $MAGIC_EMPTY_BLOB_ID)
	then fn:true()
	else fn:false()
};


(:
   Code in this section applies the change list generated by JackRabbit.
   It deletes node/properties, adds new ones and makes changes to
   existing ones.
   This does a recursive descent over the existing workspace state
   document and produces a new one.
 :)

declare private function binary-node-path ($uri-root as xs:string,
	$prop as element(property))
{
	fn:concat ($uri-root, fn:string ($prop/values/value))
};

(: Find a node's name by looking it up by id in the change list.
   When added, it should appear as a child entry for some other
   node in the change list. :)
declare private function find-node-name ($deltas as element(change-list),
	$id as xs:string)
	as xs:string
{
	fn:string ($deltas//node/nodes/node[@uuid eq $id]/@name)
};

(: Delete a property.  Delete the blob file for Binary properties,
   otherwise do nothing.
 :)
declare private function delete-property ($prop as element(property), $uri-root as xs:string)
	as empty-sequence()
{
	if ($prop/@type eq "Binary")
	then
		if (is-empty-blob ($prop))
		then ()
		else jcrfslib:delete-and-prune-dirs (binary-node-path ($uri-root, $prop), 2)
	else ()
};


declare private function blob-path-root ($data-dir as xs:string,
	$tx-id as xs:string, $prop as element(property))
	as xs:string
{
	fn:concat ("/", $data-dir, "/", $tx-id, "/",
		fn:string ($prop/@parentUUID), "/",
		fn:encode-for-uri (fn:string ($prop/@name)))
};

declare private function insert-as-xml ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string, $collections-seq as xs:string*)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".xml")
	let $uri := fn:concat ($root, $blob-path)
	let $xml as element() := xdmp:unquote (xdmp:quote ($blob), "", "repair-full")/element()

	return (xdmp:document-insert ($uri, $xml, (), $collections-seq), $blob-path)
};

declare private function insert-as-text ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string, $collections-seq as xs:string*)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".txt")
	let $uri := fn:concat ($root, $blob-path)
	let $txt as text() := text { xdmp:quote ($blob) }

	return (xdmp:document-insert ($uri, $txt, (), $collections-seq), $blob-path)
};

declare private function insert-as-binary ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string, $collections-seq as xs:string*)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".bin")
	let $uri := fn:concat ($root, $blob-path)

	return (xdmp:document-insert ($uri, $blob, (), $collections-seq), $blob-path)
};

declare private function rename-blob ($blob as binary(), $prop as element(property),
	$collections as xs:string?,
	$uri-root as xs:string, $data-dir as xs:string, $tx-id as xs:string)
	as xs:string
{
	let $new-rel-uri := blob-path-root ($data-dir, $tx-id, $prop)
	let $new-uri-root := fn:concat ($uri-root, $new-rel-uri)
	let $collections-seq as xs:string* := fn:tokenize ($collections, "\s*,\s*")

	return
	try {
		insert-as-xml ($blob, $uri-root, $new-rel-uri, $collections-seq)
	} catch ($e) {
		try {
			insert-as-text ($blob, $uri-root, $new-rel-uri, $collections-seq)
		} catch ($e) {
			insert-as-binary ($blob, $uri-root, $new-rel-uri, $collections-seq)
		}
	}
};

(: Return a new property, which is the input property element unless
   it's of type binary.  For binary properties, a document may be created.
 :)
declare private function new-property ($prop as element(property),
	$deltas as element(change-list), $collections as xs:string?, $uri-root as xs:string)
	as element(property)
{
	if (($prop/@type ne "Binary") or (is-empty-blob ($prop)))
	then $prop
	else

	let $old-blob-uri := binary-node-path ($uri-root, $prop)
	let $tx-blob := fn:doc ($old-blob-uri)/binary()
	let $new-blob-uri := rename-blob ($tx-blob, $prop, $collections, $uri-root,
		fn:string ($deltas/data-dir), fn:string ($deltas/tx-id))
	return
	<property>
		{ $prop/@* }
		<values>
			<value>{$new-blob-uri}</value>
		</values>
	</property>
};

(: Update this property, if it's on the list of modified properties.
   If modified, a new property is created, which may cause a binary
   document to be replaced.  If not modified, return the orginal element.
 :)
declare private function update-property ($prop as element(property),
	$deltas as element(change-list), $modified-props as map:map,
	$collections as xs:string?, $uri-root as xs:string)
	as element(property)*
{
	let $mod-prop := map:get ($modified-props, $prop/@parentUUID)[@name eq $prop/@name]
	return
	if ($mod-prop)
	then new-property ($mod-prop, $deltas, $collections, $uri-root)
	else $prop
};

(: If the property is on the deletion list, return nothing.  Otherwise,
   return the original element.  The function delete-property() is called
   to (possibly) delete the document corresponding to a binary property.
 :)
declare private function prune-property ($prop as element(property),
	$deltas as element(change-list), $del-props-map as map:map,
	$uri-root as xs:string)
	as element(property)*
{
	let $del-props-map := map:get ($del-props-map, $prop/@parentUUID)
	let $del-prop := if (fn:exists ($del-props-map)) then map:get ($del-props-map, $prop/@name) else ()

	return
	if ($del-prop) then delete-property ($prop, $uri-root) else $prop
};

(: Given a <references> node and the id of its parent node, if a new
   instance is in the change list, return that.  Otherwise return the
   original <references> element.
 :)
declare private function prune-references ($node-id as attribute(uuid),
	$refs as element(reference)*, $deltas as element(change-list))
	as element(reference)*
{
	if (fn:exists ($deltas/modified-refs/references[@targetId eq $node-id]))
	then $deltas/modified-refs/references[@targetId eq $node-id]/reference
	else $refs
};

(: If the candidate node does not exist in the sequence of existing nodes,
   construct and return a node, tagged with an "extref" attribute, to be
   used as a placeholder.  This case happens for nodes whose parent
   node lives in another workspace, which is allowed.
 :)
declare private function external-node ($existing-nodes as element(node)*,
	$candidate as element(node), $parent-id as xs:string)
{
	if (fn:exists ($existing-nodes[@uuid eq $candidate/@uuid]))
	then ()
	else
	<node extref="true">{
		$candidate/@*,
		attribute { "parentUUID" } { $parent-id }
	}</node>
};

(: Returns nodes that are new, but which don't have a parent in this workspace
   TODO: Can this be unified with external-node(), above
 :)
declare private function parentless-new-nodes ($state as element(workspace),
	$deltas as element(change-list))
	as element(node)*
{
	for $new-node in $deltas/added-states/node
	let $parent-id := $new-node/@parentUUID
	where fn:empty ($deltas/added-states/node[@uuid eq $parent-id]) and
			fn:empty ($state//node[@uuid eq $parent-id])
	return $new-node
};

(: Apply updates for this node.  An update could mean creating a new node,
   in which case the input node is the one in the change list.  The first
   step is to recurse down and apply updates to child nodes.  Once all
   children have been updated, a new node element is created and returned,
   which may entail replacing the current node with one from the change list.
   New nodes in the change list do not have name attributes, so the name
   is looked up (in other nodes in the changelist) if necessary.
   Note function mapping.
 :)
declare private function update-node ($node as element(node),
	$deltas as element(change-list),
	$added-nodes-by-parent as map:map, $added-props-by-parent as map:map,
	$modified-nodes as map:map, $modified-props as map:map,
	$affected-nodes as map:map, $collections as xs:string?, $uri-root as xs:string)
	as element(node)?
{
	let $node-id := $node/@uuid

	return
	if ((map:get ($affected-nodes, $node-id)) or (map:keys ($affected-nodes) = $node//@uuid))
	then
	<node>{
		let $replace-node := map:get ($modified-nodes, $node-id)
		let $name-attr := if ($node/@name)
			then $node/@name
			else attribute { "name" } { find-node-name ($deltas, $node-id) }  (: FIXME :)
		let $current-node := if ($replace-node) then $replace-node else $node
		let $added-nodes := map:get ($added-nodes-by-parent, $node-id)
		let $added-props := map:get ($added-props-by-parent, $node-id)
		return
		(
			if ($current-node/@name) then () else $name-attr,
			$current-node/@*,
			$current-node/mixinTypes,
			(update-property ($node/property, $deltas, $modified-props, $collections, $uri-root),
				new-property ($added-props, $deltas, $collections, $uri-root)),
			(update-node ($node/node, $deltas, $added-nodes-by-parent, $added-props-by-parent, $modified-nodes, $modified-props, $affected-nodes, $collections, $uri-root),
				update-node ($added-nodes, $deltas, $added-nodes-by-parent, $added-props-by-parent, $modified-nodes, $modified-props, $affected-nodes, $collections, $uri-root)),
			external-node (($node/node, $added-nodes),
				$deltas/(added-states|modified-states)/node[@uuid eq $node-id]/nodes/node, fn:string ($node-id)),
			prune-references ($node-id, $node/reference, $deltas)
		)
	}</node>
	else $node
};

(: Apply updates to the workspace tree (adds and modifies).  This
   function assumes that deleted nodes/properies have already been
   pruned away.
 :)
declare private function apply-updates ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	let $added-nodes-by-parent := map:map()
	let $dummy :=
		for $uuid in fn:distinct-values (fn:data ($deltas/added-states/node/@parentUUID))
		return map:put ($added-nodes-by-parent, $uuid, $deltas/added-states/node[@parentUUID eq $uuid])

	let $added-props-by-parent := map:map()
	let $dummy :=
		for $uuid in fn:distinct-values (fn:data ($deltas/added-states/property/@parentUUID))
		return map:put ($added-props-by-parent, $uuid, $deltas/added-states/property[@parentUUID eq $uuid])

	let $modified-nodes := map:map()
	let $dummy :=
		for $uuid in fn:data ($deltas/modified-states/node/@uuid)
		return map:put ($modified-nodes, $uuid, $deltas/modified-states/node[@uuid eq $uuid])

	let $modified-props := map:map()
	let $dummy :=
		for $uuid in fn:distinct-values (fn:data ($deltas/modified-states/property/@parentUUID))
		return map:put ($modified-props, $uuid, $deltas/modified-states/property[@parentUUID eq $uuid])

	let $affected-nodes := map:map()
	let $dummy := map:put ($affected-nodes, fn:distinct-values ((map:keys ($added-nodes-by-parent),
		map:keys ($added-props-by-parent), map:keys ($modified-nodes), map:keys ($modified-props),
		fn:data ($deltas/modified-refs/references/@targetId))), fn:true())

	let $collections := fn:string ($state/@collections)

	return
	<workspace>{
		$state/@*,
		update-node ($state/node, $deltas, $added-nodes-by-parent, $added-props-by-parent, $modified-nodes, $modified-props, $affected-nodes, $collections, $uri-root),
		update-node (parentless-new-nodes ($state, $deltas), $deltas, $added-nodes-by-parent, $added-props-by-parent, $modified-nodes, $modified-props, $affected-nodes, $collections, $uri-root)
	}</workspace>
};

(: Attempt to prune this node.  Any child nodes and/or properties are
   first pruned in case they have been deleted.  Then the change list
   is checked to see if this node has been deleted.  If so, return the
   empty sequence.  If not deleted, return a copy of this node with the
   surviving child nodes.
   Note use of function mapping to automatically iterate child nodes.
 :)
declare private function prune-node ($node as element(node),
	$deltas as element(change-list), $del-nodes-map as map:map,
	$del-props-map as map:map, $affected-nodes-map as map:map,
	$uri-root as xs:string)
	as element(node)?
{
	let $node-id := $node/@uuid

	return
	if (map:get ($del-nodes-map, $node-id))
	then ()
	else
		if ((map:get ($affected-nodes-map, $node-id)) or ($node//@uuid = map:keys ($affected-nodes-map)))
		then
			<node>{
				$node/@*,
				$node/mixinTypes,
				prune-property ($node/property, $deltas, $del-props-map, $uri-root),
				prune-node ($node/node, $deltas, $del-nodes-map, $del-props-map, $affected-nodes-map, $uri-root),
				prune-references ($node-id, $node/reference, $deltas)
			}</node>
		else $node
};

(: Recurse down the workspace state tree and prune out deleted nodes.
   Pruning nodes implies pruning contained properties, which may cause
   document deletions.
 :)
declare private function prune-deleted ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	let $del-nodes-map := map:map()
	let $dummy := map:put ($del-nodes-map, $deltas/deleted-states/node/@uuid, fn:true())  (: func mapping here :)
	let $del-props-map := map:map()
	let $dummy :=
		for $uuid in fn:distinct-values (fn:data ($deltas/deleted-states/property/@parentUUID))
		return map:put ($del-props-map, $uuid,
			let $props-map := map:map()
			let $dummy := map:put ($props-map, $deltas/deleted-states/property[@parentUUID eq $uuid]/@name, fn:true())
			return $props-map)
	let $affected-nodes-map := map:map()
	let $dummy := map:put ($affected-nodes-map, (map:keys ($del-nodes-map), map:keys ($del-props-map)), fn:true())

	return
	if (map:count ($affected-nodes-map) eq 0)
	then $state
	else
	<workspace>{
		$state/@*,
		prune-node ($state/node, $deltas, $del-nodes-map, $del-props-map, $affected-nodes-map, $uri-root)   (: function mapping here :)
	}</workspace>
};

(: Returns a new workspace node with deltas applied :)
declare function apply-state-updates ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	let $dummy := if ($save-update-profile-data) then prof:enable (xdmp:request()) else ()

	let $pruned := prune-deleted ($state, $deltas, $uri-root)
	let $new-state := apply-updates ($pruned, $deltas, $uri-root)

	let $dummy := if ($save-debug-history) then save-debug-history ($uri-root, $state, $pruned, $new-state, $deltas) else ()
	let $dummy := if ($save-update-profile-data) then save-profile-data ($uri-root, prof:report (xdmp:request())) else ()

	return $new-state
};

(: =============================================================== :)

declare function gather-new-blob-uris ($state as element(workspace),
	$deltas as element(change-list))
{
	for $prop in $deltas/(added-states|modified-states)/property[@type eq "Binary"]
	let $new-prop := $state//property[@parentUUID eq $prop/@parentUUID][@name eq $prop/@name]
	where fn:not (is-empty-blob ($prop))
	return
	fn:concat (fn:string ($new-prop/@parentUUID), "|", fn:string ($new-prop/@name), "|", fn:string ($new-prop/values/value))
};

(: =============================================================== :)

declare function check-node-exists ($state as element(workspace), $id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[@uuid eq $id][fn:not(@extref)])
};

declare function query-node-state ($state as element(workspace), $id as xs:string)
	as element(node)?
{
	let $node as element(node)? := $state//node[@uuid eq $id][fn:not(@extref)]

	return
	if (fn:empty ($node))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,

		<nodes>{
			for $n in $node/node
			return
			<node>{
				$n/@name, $n/@uuid
			}</node>
		}</nodes>,

		<properties>{
			for $prop in $node/property
			return
			<property>{$prop/@name}</property>
		}</properties>
	}</node>
};

(: =============================================================== :)

declare function check-property-exists ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) eq $id]/property[fn:string(@name) eq $name])
};

declare function query-property-state ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as element(property)?
{
	$state//node[fn:string(@uuid) eq $id]/property[fn:string(@name) eq $name]
};

(: =============================================================== :)

declare function check-reference-exists ($state as element(workspace),
	$id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) eq $id]/reference)
};

declare function query-references-state ($state as element(workspace),
	$id as xs:string)
	as element(references)
{
	let $node := $state//node[fn:string(@uuid) eq $id]
	return
	<references>{
		attribute { "targetId" } { $id },
		for $ref in $node/reference
		let $nodeId := fn:string ($ref/@parentUUID)
		let $propName := $ref/@name
		return
		<reference>{
			attribute { "propertyId" } { fn:concat ($nodeId, "/", $propName) }
		}</reference>
	}</references>
};

(: =============================================================== :)
