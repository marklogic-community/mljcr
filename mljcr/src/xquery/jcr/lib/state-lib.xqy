
xquery version "1.0-ml";

module namespace jcrstatelib="http://marklogic.com/jcr/state";

declare default element namespace "http://marklogic.com/jcr";

(: =============================================================== :)
(:
   Code in this section applies the change list generated by JackRabbit.
   It deletes node/properties, adds new ones and makes changes to
   existing ones.
   This does a recursive descent over the existing workspace state
   document and produces another one, which replaces the old one.
 :)

(: Find a node's name by looking it up by id in the change list.
   When added, it should appear as a child entry for some other
   node in the change list. :)
declare private function find-node-name ($deltas as element(change-list),
	$id as xs:string)
	as xs:string
{
	fn:string ($deltas//node/nodes/node[@uuid = $id]/@name)
};

(: Delete a property.  Delete the blob file for Binary properties,
   otherwise do nothing.
 :)
declare private function delete-property ($prop as element(property))
	as empty-sequence()
{
	(: TODO: delete blob if type = Binary :)
	()
};

declare private function new-property ($prop as element(property))
	as element(property)
{
	(: TODO: handle binary properties, move/re-insert document :)
	$prop
};

declare private function update-property ($prop as element(property),
	$deltas as element(change-list))
	as element(property)*
{
	if (fn:exists ($deltas/modified-states/property[@parrentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then new-property ($deltas/modified-states/property[@parentUUID = $prop/@parentUUID][@name = $prop/@name])
	else $prop
};

declare private function prune-property ($prop as element(property),
	$deltas as element(change-list))
	as element(property)*
{
	if (fn:exists ($deltas/deleted-states/property[@parrentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then delete-property ($prop)
	else $prop
};

declare private function prune-references ($node-id as attribute(uuid),
	$refs as element(reference)*, $deltas as element(change-list))
	as element(reference)*
{
	if (fn:exists ($deltas/modified-refs/references[@targetId = $node-id]))
	then $deltas/modified-refs/references[@targetId = $node-id]/reference
	else $refs
};

declare private function external-node ($existing-nodes as element(node)*,
	$candidate as element(node), $parent-id as xs:string)
{
	if (fn:exists ($existing-nodes[@uuid = $candidate/@uuid]))
	then ()
	else
	<node extref="true">{
		$candidate/@*,
		attribute { "parentUUID" } { $parent-id }
	}</node>
};

declare private function update-node ($node as element(node),
	$deltas as element(change-list))
	as element(node)?
{
	(: need to recurse down to handle deleted binary nodes :)
	(: note function mapping :)
	let $node-id := $node/@uuid
	let $child-nodes := (update-node ($node/node, $deltas),
		update-node ($deltas/added-states/node[@parentUUID = $node-id], $deltas))
	let $added-external-nodes := external-node ($child-nodes,
		$deltas/(added-states|modified-states)/node[@uuid = $node-id]/nodes/node,
		fn:string ($node-id))
	let $child-properties := (update-property ($node/property, $deltas),
		new-property ($deltas/added-states/property[@parentUUID = $node-id]))
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	<node>{
		let $replace-node := $deltas/modified-states/node[@uuid = $node-id]
		let $name-attr := if ($node/@name)
			then $node/@name
			else attribute { "name" } { find-node-name ($deltas, $node-id) }
		let $node := if ($replace-node) then $replace-node else $node
		return
		(
			if ($node/@name) then () else $name-attr,
			$node/@*,
			$node/mixinTypes,
			$child-properties,
			$child-nodes,
			$added-external-nodes,
			$child-refs
		)
	}</node>
};

declare private function prune-node ($node as element(node),
	$deltas as element(change-list))
	as element(node)?
{
	(: need to recurse down to handle deleted binary nodes :)
	(: note function mapping :)
	let $node-id := $node/@uuid
	let $child-nodes := prune-node ($node/node, $deltas)
	let $child-properties := prune-property ($node/property, $deltas)
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	if (fn:exists ($deltas/deleted-states/node[@uuid = $node-id]))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,
		$child-properties,
		$child-nodes,
		$child-refs
	}</node>
};

declare private function parentless-new-nodes ($state as element(workspace),
	$deltas as element(change-list))
	as element(node)*
{
	for $new-node in $deltas/added-states/node
	let $parent-id := $new-node/@parentUUID
	where fn:empty (($deltas/added-states/node[@uuid = $parent-id],
			$state//node[@uuid = $parent-id]))
	return $new-node
};

declare private function apply-updates ($state as element(workspace),
	$deltas as element(change-list))
	as element(workspace)
{
	<workspace>{
		$state/@*,
		update-node ($state/node, $deltas),
		update-node (parentless-new-nodes ($state, $deltas), $deltas)
	}</workspace>
};


declare (: private :) function prune-deleted ($state as element(workspace),
	$deltas as element(change-list))
	as element(workspace)
{
	<workspace>{
		$state/@*,
		prune-node ($state/node, $deltas)
	}</workspace>
};

(: Returns a new workspace node with deltas applied :)
declare function apply-state-updates ($state as element(workspace),
	$deltas as element(change-list))
	as element(workspace)
{
	apply-updates (prune-deleted ($state, $deltas), $deltas)
};


(: ========= :)
(: ========= :)
(: ========= :)

(: =============================================================== :)

declare function check-node-exists ($state as element(workspace), $id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[@uuid = $id][fn:not(@extref)])
};

declare function query-node-state ($state as element(workspace), $id as xs:string)
	as element(node)?
{
	let $node as element(node)? := $state//node[@uuid = $id][fn:not(@extref)]

	return
	if (fn:empty ($node))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,

		<nodes>{
			for $n in $node/node
			return
			<node>{
				$n/@name, $n/@uuid
			}</node>
		}</nodes>,

		<properties>{
			for $prop in $node/property
			return
			<property>{$prop/@name}</property>
		}</properties>
	}</node>
};

(: =============================================================== :)

declare function check-property-exists ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name])
};

declare function query-property-state ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as element(property)?
{
	$state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name]
};

(: =============================================================== :)

declare function check-reference-exists ($state as element(workspace),
	$id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/reference)
};

declare function query-references-state ($state as element(workspace),
	$id as xs:string)
	as element(references)
{
	let $node := $state//node[fn:string(@uuid) = $id]
	return
	<references>{
		attribute { "targetId" } { $id },
		for $ref in $node/reference
		let $nodeId := fn:string ($ref/@parentUUID)
		let $propName := $ref/@name
		return
		<reference>{
			attribute { "propertyId" } { fn:concat ($nodeId, "/", $propName) }
		}</reference>
	}</references>
};

(: =============================================================== :)
