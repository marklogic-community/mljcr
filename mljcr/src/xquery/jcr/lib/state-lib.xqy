
xquery version "1.0-ml";

module namespace jcrstatelib="http://marklogic.com/jcr/state";

import module namespace jcrfslib="http://marklogic.com/jcr/fs" at "fs-lib.xqy";

declare default element namespace "http://marklogic.com/jcr";

(: keep this is sync with Java :)
declare variable $MAGIC_EMPTY_BLOB_ID := "@=-empty-=@";

declare variable $save-debug-history := fn:false();

(: =============================================================== :)
(: Debug functions to save update history :)

declare private function get-counter ($uri as xs:string) as xs:string
{
	let $prev-number as xs:integer? := xs:integer (fn:doc ($uri)/counter)
	let $number := if (fn:exists ($prev-number)) then ($prev-number + 1) else 1
	let $dummy := xdmp:document-insert ($uri, <counter>{$number}</counter>)
	return
	if ($number < 10)
	then fn:concat ("00", $number)
	else if ($number < 100)
	then fn:concat ("0", $number)
	else fn:string ($number)
};

declare private function save-debug-history ($uri-root as xs:string,
	$old-state as element(workspace), $pruned as element(workspace),
	$new-state as element(workspace), $deltas as element(change-list))
{
	let $base-uri := fn:concat ($uri-root, "/history/")
	let $counter-uri := fn:concat ($base-uri, "history-counter.xml")
	let $number := get-counter ($counter-uri)
	let $history-uri := fn:concat ($base-uri, "state-history-", $number, ".xml")
	return xdmp:document-insert ($history-uri,
		<history uri="{$history-uri}">
			<before>{$old-state}</before>
			<pruned>{$pruned}</pruned>
			<deltas>{$deltas}</deltas>
			<after>{$new-state}</after>
		</history>
	)
};

(: =============================================================== :)


declare private function is-empty-blob ($prop as element(property))
	as xs:boolean
{
	if (fn:string ($prop/values/value) = $MAGIC_EMPTY_BLOB_ID)
	then fn:true()
	else fn:false()
};


(:
   Code in this section applies the change list generated by JackRabbit.
   It deletes node/properties, adds new ones and makes changes to
   existing ones.
   This does a recursive descent over the existing workspace state
   document and produces a new one.
 :)

declare private function binary-node-path ($uri-root as xs:string,
	$prop as element(property))
{
	fn:concat ($uri-root, fn:string ($prop/values/value))
};

(: Find a node's name by looking it up by id in the change list.
   When added, it should appear as a child entry for some other
   node in the change list. :)
declare private function find-node-name ($deltas as element(change-list),
	$id as xs:string)
	as xs:string
{
	fn:string ($deltas//node/nodes/node[@uuid = $id]/@name)
};

(: Delete a property.  Delete the blob file for Binary properties,
   otherwise do nothing.
 :)
declare private function delete-property ($prop as element(property), $uri-root as xs:string)
	as empty-sequence()
{
	if ($prop/@type = "Binary")
	then
		if (is-empty-blob ($prop))
		then ()
		else jcrfslib:delete-and-prune-dirs (binary-node-path ($uri-root, $prop), 2)
	else ()
};


declare private function blob-path-root ($data-dir as xs:string,
	$tx-id as xs:string, $prop as element(property))
	as xs:string
{
	fn:concat ("/", $data-dir, "/", $tx-id, "/",
		fn:string ($prop/@parentUUID), "/",
		fn:encode-for-uri (fn:string ($prop/@name)))
};

declare private function insert-as-xml ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".xml")
	let $uri := fn:concat ($root, $blob-path)
	let $xml as element() := xdmp:unquote (xs:hexBinary (xs:string ($blob)), "", "repair-full")/element()

	return (xdmp:document-insert ($uri, $xml), $blob-path)
};

declare private function insert-as-text ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".txt")
	let $uri := fn:concat ($root, $blob-path)
	let $txt as text() := text { xs:hexBinary (xs:string ($blob)) }
(:
let $dummy := xdmp:log (fn:concat ("Inserted text: ", $txt))
:)
let $dummy := fn:error()   (: disable for now :)

	return (xdmp:document-insert ($uri, $txt), $blob-path)
};

declare private function insert-as-binary ($blob as binary(), $root as xs:string,
	$blob-path-root as xs:string)
	as xs:string
{
	let $blob-path := fn:concat ($blob-path-root, ".bin")
	let $uri := fn:concat ($root, $blob-path)

	return (xdmp:document-insert ($uri, $blob), $blob-path)
};

declare private function rename-blob ($blob as binary(), $prop as element(property),
	$uri-root as xs:string, $data-dir as xs:string, $tx-id as xs:string)
	as xs:string
{
	let $new-rel-uri := blob-path-root ($data-dir, $tx-id, $prop)
	let $new-uri-root := fn:concat ($uri-root, $new-rel-uri)

	return
	try {
		insert-as-xml ($blob, $uri-root, $new-rel-uri)
	} catch ($e) {
		try {
			insert-as-text ($blob, $uri-root, $new-rel-uri)
		} catch ($e) {
			insert-as-binary ($blob, $uri-root, $new-rel-uri)
		}
	}
};

(: Return a new property, which is the input property element unless
   it's of type binary.  For binary properties, a document may be created.
 :)
declare private function new-property ($prop as element(property),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(property)
{
	if (($prop/@type ne "Binary") or (is-empty-blob ($prop)))
	then $prop
	else

	let $old-blob-uri := binary-node-path ($uri-root, $prop)
	let $tx-blob := fn:doc ($old-blob-uri)/binary()
	let $new-blob-uri := rename-blob ($tx-blob, $prop, $uri-root,
		fn:string ($deltas/data-dir), fn:string ($deltas/tx-id))
	return
	<property>
		{ $prop/@* }
		<values>
			<value>{$new-blob-uri}</value>
		</values>
	</property>
};

(: Update this property, if it's on the list of modified properties.
   If modified, a new property is created, which may cause a binary
   document to be replaced.  If not modified, return the orginal element.
 :)
declare private function update-property ($prop as element(property),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(property)*
{
	if (fn:exists ($deltas/modified-states/property[@parentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then new-property ($deltas/modified-states/property[@parentUUID = $prop/@parentUUID][@name = $prop/@name], $deltas, $uri-root)
	else $prop
};

(: If the property is on the deletion list, return nothing.  Otherwise,
   return the original element.  The function delete-property() is called
   to (possibly) delete the document corresponding to a binary property.
 :)
declare private function prune-property ($prop as element(property),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(property)*
{
	if (fn:exists ($deltas/deleted-states/property[@parentUUID = $prop/@parentUUID][@name = $prop/@name]))
	then delete-property ($prop, $uri-root)
	else $prop
};

(: Given a <referenceds> node and the id of its parent node, if a new
   instance is in the change list, return that.  Otherwise return the
   original <references> element.
 :)
declare private function prune-references ($node-id as attribute(uuid),
	$refs as element(reference)*, $deltas as element(change-list))
	as element(reference)*
{
	if (fn:exists ($deltas/modified-refs/references[@targetId = $node-id]))
	then $deltas/modified-refs/references[@targetId = $node-id]/reference
	else $refs
};

(: If the candidate node does not exist in the sequence of existing nodes,
   construct and return a node, tagged with an "extref" attribute, to be
   used as a placeholder.  This case happens for nodes whose parent
   node lives in another workspace, which is allowed.
 :)
declare private function external-node ($existing-nodes as element(node)*,
	$candidate as element(node), $parent-id as xs:string)
{
	if (fn:exists ($existing-nodes[@uuid = $candidate/@uuid]))
	then ()
	else
	<node extref="true">{
		$candidate/@*,
		attribute { "parentUUID" } { $parent-id }
	}</node>
};

(: Returns nodes that are new, but which don't have a parent in this workspace
   TODO: Can this be unified with external-node(), above
 :)
declare private function parentless-new-nodes ($state as element(workspace),
	$deltas as element(change-list))
	as element(node)*
{
	for $new-node in $deltas/added-states/node
	let $parent-id := $new-node/@parentUUID
	where fn:empty (($deltas/added-states/node[@uuid = $parent-id],
			$state//node[@uuid = $parent-id]))
	return $new-node
};

(: Apply updates for this node.  An update could mean creating a new node,
   in which can the input node is the one in the change list.  The first
   step is to recurse down and apply updates to child nodes.  Once all
   children have been updated, a new node level is created and returned,
   which may entail replacing the current node with one from the change list.
   New nodes in the change list do not have name attributes, so the name
   is looked up (in other nodes in the changelist) if necessary.
   Note function mapping.
 :)
declare private function update-node ($node as element(node),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(node)?
{
	(: note function mapping :)
	let $node-id := $node/@uuid
	let $child-nodes := (update-node ($node/node, $deltas, $uri-root),
		update-node ($deltas/added-states/node[@parentUUID = $node-id], $deltas, $uri-root))
	let $added-external-nodes := external-node ($child-nodes,
		$deltas/(added-states|modified-states)/node[@uuid = $node-id]/nodes/node,
		fn:string ($node-id))
	let $child-properties := (update-property ($node/property, $deltas, $uri-root),
		new-property ($deltas/added-states/property[@parentUUID = $node-id], $deltas, $uri-root))
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	<node>{
		let $replace-node := $deltas/modified-states/node[@uuid = $node-id]
		let $name-attr := if ($node/@name)
			then $node/@name
			else attribute { "name" } { find-node-name ($deltas, $node-id) }
		let $node := if ($replace-node) then $replace-node else $node
		return
		(
			if ($node/@name) then () else $name-attr,
			$node/@*,
			$node/mixinTypes,
			$child-properties,
			$child-nodes,
			$added-external-nodes,
			$child-refs
		)
	}</node>
};

(: Attempt to prune this node.  Any child nodes and/or properties are
   first pruned in case they have been deleted.  Then the change list
   is checked to see if this node has been deleted.  If so, return the
   empty sequence.  If not deleted, return a copy of this node with the
   surviving child nodes.
   Note use of function mapping to automatically iterate child nodes.
 :)
declare private function prune-node ($node as element(node),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(node)?
{
	let $node-id := $node/@uuid
	let $child-nodes := prune-node ($node/node, $deltas, $uri-root)
	let $child-properties := prune-property ($node/property, $deltas, $uri-root)
	let $child-refs := prune-references ($node-id, $node/reference, $deltas)
	return
	if (fn:exists ($deltas/deleted-states/node[@uuid = $node-id]))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,
		$child-properties,
		$child-nodes,
		$child-refs
	}</node>
};

(: Apply updates to the workspace tree (adds and modifies).  This
   function assumes that deleted nodes/properies have already been
   pruned away.
 :)
declare private function apply-updates ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	<workspace>{
		$state/@*,
		update-node ($state/node, $deltas, $uri-root),
		update-node (parentless-new-nodes ($state, $deltas), $deltas, $uri-root)
	}</workspace>
};

(: Recurse down the workspace state tree and prune out deleted nodes.
   Pruning nodes implies pruning contained properties, which may cause
   document deletions.
 :)
declare private function prune-deleted ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	<workspace>{
		$state/@*,
		prune-node ($state/node, $deltas, $uri-root)   (: function mapping here :)
	}</workspace>
};

(: Returns a new workspace node with deltas applied :)
declare function apply-state-updates ($state as element(workspace),
	$deltas as element(change-list), $uri-root as xs:string)
	as element(workspace)
{
	let $pruned := prune-deleted ($state, $deltas, $uri-root)
	let $new-state := apply-updates ($pruned, $deltas, $uri-root)
	let $dummy := if ($save-debug-history) then save-debug-history ($uri-root, $state, $pruned, $new-state, $deltas) else ()

	return $new-state
};

(: =============================================================== :)

declare function gather-new-blob-uris ($state as element(workspace),
	$deltas as element(change-list))
{
	for $prop in $deltas/(added-states|modified-states)/property[@type = "Binary"]
	let $new-prop := $state//property[@parentUUID = $prop/@parentUUID][@name = $prop/@name]
	where fn:not (is-empty-blob ($prop))
	return
	fn:concat (fn:string ($new-prop/@parentUUID), "|", fn:string ($new-prop/@name), "|", fn:string ($new-prop/values/value))
};

(: =============================================================== :)

declare function check-node-exists ($state as element(workspace), $id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[@uuid = $id][fn:not(@extref)])
};

declare function query-node-state ($state as element(workspace), $id as xs:string)
	as element(node)?
{
	let $node as element(node)? := $state//node[@uuid = $id][fn:not(@extref)]

	return
	if (fn:empty ($node))
	then ()
	else
	<node>{
		$node/@*,
		$node/mixinTypes,

		<nodes>{
			for $n in $node/node
			return
			<node>{
				$n/@name, $n/@uuid
			}</node>
		}</nodes>,

		<properties>{
			for $prop in $node/property
			return
			<property>{$prop/@name}</property>
		}</properties>
	}</node>
};

(: =============================================================== :)

declare function check-property-exists ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name])
};

declare function query-property-state ($state as element(workspace),
	$id as xs:string, $name as xs:string)
	as element(property)?
{
	$state//node[fn:string(@uuid) = $id]/property[fn:string(@name) = $name]
};

(: =============================================================== :)

declare function check-reference-exists ($state as element(workspace),
	$id as xs:string)
	as xs:boolean
{
	fn:exists ($state//node[fn:string(@uuid) = $id]/reference)
};

declare function query-references-state ($state as element(workspace),
	$id as xs:string)
	as element(references)
{
	let $node := $state//node[fn:string(@uuid) = $id]
	return
	<references>{
		attribute { "targetId" } { $id },
		for $ref in $node/reference
		let $nodeId := fn:string ($ref/@parentUUID)
		let $propName := $ref/@name
		return
		<reference>{
			attribute { "propertyId" } { fn:concat ($nodeId, "/", $propName) }
		}</reference>
	}</references>
};

(: =============================================================== :)
